/*
 * @file midi.c
 * @brief functions for playing MIDI files on the robot
 * @since Jul 20, 2011
 * @author Sunny Kim
 * @warning Many functions are not commented
 */

#if (defined(RONE_V9) || defined(RONE_V12))

#include <string.h>
#include "roneos.h"


/******** Defines ********/
#define MIDI_DATA_LENGTH	128
#define MIDI_MSG_ADDRESS 	0
#define MIDI_MSG_TRACKS  	1

#define MIDI_MAX_TRACK_LENGTH			32768
#define MIDI_DEFAULT_TEMPO 	500000

//#define MIDI_DURATION		0

#define MIDI_THREAD_PERIOD 				1
#define MIDI_THREAD_PERIOD_OUTER 		10

/* ERROR CODES
 * These are the error codes returned by the various routines.
 */
#define MFE_OK		  0	/* No error */
#define MFE_EOF		 -1	/* Premature end of file */
#define MFE_HKWEXP	 -2	/* Header keyword expected */
#define MFE_NOGETC	 -3	/* 'Mf_getc' is not defined */
#define MFE_ILLHLEN	 -4	/* Illegal header length */
#define MFE_USER	 -5	/* User disapproves of something */
#define MFE_ILLFORM	 -6	/* Illegal file format */
#define MFE_TKWEXP	 -7	/* Track keyword expected */
#define MFE_ILLSETYPE	 -8	/* Illegal SysEx message type */
#define MFE_MEM		 -9	/* Insufficient memory */
#define MFE_ILLSTAT	-10	/* Illegal status byte */
#define MFE_ILLMLEN	-11	/* Illegal meta-event length */
#define MFE_ILLMVAL	-12	/* Illegal value in meta-event */
#define MFE_UKMETA	-13	/* Unknown meta-event */
#define MFE_NOEOT	-14	/* No end-of-track meta-event */
#define MFE_TOO_MANY_TRACKS	-15	/* Too many tracks in this midi file */
#define MFE_TRACK_TOO_LONG	-16	/* Too many tracks in this midi file */

/* META-EVENT MESSAGE TYPES */
#define META_SEQNUM		0x00	/* Sequence number */
#define META_TEXT		0x01	/* Text event */
#define META_COPYRIGHT	0x02	/* Copyright notice */
#define META_SEQNAME	0x03	/* Sequence/track name */
#define META_INSTNAME	0x04	/* Instrument name */
#define META_LYRIC		0x05	/* Lyric */
#define META_MARKER		0x06	/* Marker */
#define META_CUEPT		0x07	/* Cue point */
#define META_EOT		0x2f	/* End of track */
#define META_TEMPO		0x51	/* Set tempo */
#define META_SMPTE		0x54	/* SMPTE offset */
#define META_TIMESIG	0x58	/* Time signature */
#define META_KEYSIG		0x59	/* Key signature */
#define META_SEQSPEC	0x7f	/* Sequencer-specific event */


#define MIDI_PRECUSSION_CHANNEL 9

#include "VS1053.h"


/* @brief Represents a MIDI track.
 * Should be generated by the tool MIDIToC, not created by hand.
 */
typedef struct MIDITrackStruct {
	uint8 program;
	uint8 volume;
	boolean endOfTrack;
	uint8 * trackDataStartPtr;
	uint8 * trackDataPtr;
	uint32 trackLength;
	uint32 nextEventTime;
	uint8 runningStatus;
	uint16 index;
} MIDITrackStruct;


/******** Constants ********/
static const MIDITrackStruct MIDITrackInit = {
              /*  uint8 program */ 0,
               /*  uint8 volume */ 0,
         /*  boolean endOfTrack */ 0,
  /*  uint8 * trackDataStartPtr */ 0,
       /*  uint8 * trackDataPtr */ 0,
         /*  uint32 trackLength */ 0,
        /* uint32 nextEventTime */ 0,
        /*  uint8 runningStatus */ 0,
               /*  uint16 index */ 0,
};


/******** Variables ********/
static MIDITrackStruct MIDITracks[MIDI_TRACKS_MAX];

static uint32 currentMIDITicks = 0;
static uint32 currentMIDITime = 0;
static uint32 tempoChangeMIDITicks = 0;
static uint32 tempoChangeTime = 0;

static uint32 midiMessage[2];

static boolean playMidi = FALSE;
static boolean stopSong = FALSE;

// MIDI config
static boolean enabled = TRUE;

/** Tempo in usec/midi tick */
static uint32 tempo = 0;

/** event-level verbose count */
static boolean verbose = FALSE;

//	uint32 *timerPtr; /** James got rid of the use of this in MIDI.c v. 1.68.  Why? */


// MIDI status
/** The number of tracks in the currently playing MIDI File. */
static uint16 numberOfTracks;

/** The number of delta-time ticks in a quarter note for this MIDI song. */
static uint16 division;

/** The threadX time that this song started. */
static uint32 songStartTimeTX;

/** The time the next MIDI event will occur, in threadX ticks. */
static uint32 nextEventTimes[MIDI_TRACKS_MAX];

static uint8 currentEventType;



/* ERR_MSGS
 * Error messages corresponding to the various errors that might occur.
 */
static char *MIDI_err_msgs[] = {
	"No error",
	"Premature end of file",
	"'MThd' expected",
	"'Mf_getc' undefined",
	"Illegal header length",
	"User disapproval",
	"Illegal file format",
	"'MTrk' expected",
	"Illegal system-exclusive message type",
	"Insufficient memory",
	"Illegal status byte",
	"Illegal meta-event length",
	"Illegal value in meta-event",
	"Unknown meta-event",
	"Missing end-of-track meta-event",
	"Too many tracks",
	NULL
};

/******** Functions ********/

/*
 * @brief Plays given patch on a given channel.  The caller is responsible for settung up the channel and turning the note off.
 *
 * @param channel Track channel(number) of the note playing.
 * @param patch TODO
 * @returns void
 */
void audioMIDIChangePatch(uint8 channel, uint8 patch);

/*
 * @brief Plays given TODO on a given channel.  The caller is responsible for settung up the channel and turning the note off.
 *
 * @param channel  Track channel(number) of the note playing.
 * @param key Note to play
 * @param velocity TODO
 * @returns void
 */
void audioMIDINoteOn(uint8 channel, uint8 key, uint8 velocity);

/*
 * @brief Turns off given note.
 *
 * @param channel Track channel(number) of the note playing. Same as the soundchip channel.
 * @param key Note to turn off
 * @param velocity TODO
 * @returns void
 *
 */
void audioMIDINoteOff(uint8 channel, uint8 key, uint8 velocity);



//void MIDITempoSet(uint32 MIDITempo);
//
//int Mf_error(int8 code);
//int Mf_error2(int8 code, int32 arg);
//int Mf_on(uint8 MIDIChannel, uint8 param0, uint8 param1, boolean verbose);
//int Mf_off(uint8 MIDIChannel, uint8 param0, uint8 param1, boolean verbose);
//int Mf_pressure(uint8 MIDIChannel, uint8 param0, uint8 param1);
//int Mf_controller(uint8 MIDIChannel, uint8 param0, uint8 param1);
//int Mf_pitchbend(uint8 MIDIChannel, uint8 param0, uint8 param1);
//int Mf_program(uint8 MIDIChannel, uint8 param0);
//int Mf_chanpressure(uint8 MIDIChannel, uint8 param0);
//int Mf_sqspecific(int32 junk, uint32 length, char * data);
//int Mf_seqnum(uint16 seqNum);
//int Mf_text(int msgType, int32 length, char * data);
//int Mf_marker(int msgType, int32 length, char * data);
//int Mf_cue(int msgType, int32 length, char * data);
//int Mf_eot(MIDITrackStruct * MIDITrackPtr);
//int Mf_timesig(int32 numer, int32 denom, int32 clocks, int32 qnotes);
//int Mf_smpte(int32 hour, int32 min, int32 sec, int32 frame, int32 fract);
//int Mf_tempo(uint32 tempo);
//int Mf_keysig(int8 sharpFlat, int8 minor);


/*
 * @brief Set MIDI tempo.
 *
 * @param MIDITempo Tempo to which to set sound to.
 * @returns void
 */
static void MIDITempoSet(uint32 MIDITempo) {
    // midi tempo is in usec/quarternote.
    // rone tempo is in usec/midi tick, so convert.
	if (division == 0) {
		division = 1;
		cprintf("error-no MIDI division set\n");
	}
	tempo = MIDITempo;

	tempoChangeMIDITicks = currentMIDITicks;
	tempoChangeTime = currentMIDITime;

	if (verbose) {
		cprintf("tempo = %d\n", MIDITempo);
	}
}


/*
 * @brief Turn MIDI note on.
 *
 * @param MIDIChannel Track channel to play note. Same as the soundchip channel.
 * @param key is integer corresponding to which note to play
 * @param velocity is integer corresponding to which volume to play
 * @param verbose is boolean corresponding to whether or not to print error messages
 * @returns 0
 */
static int Mf_on(uint8 MIDIChannel, uint8 key, uint8 velocity, boolean verbose) {
//	if (velocity != 0) {
//		audioMIDINoteOn(key, velocity, MIDITracks[MIDIChannel].program, MIDI_DURATION);
//	} else {
//		audioMIDINoteOff(MIDIChannel, key, MIDITracks[MIDIChannel].program);
//	}
	audioMIDINoteOn(MIDIChannel, key, velocity);
	return(MFE_OK);
}


/*
 * @brief Turn MIDI note off.
 *
 * Parameters are same as Mf_on, but to turn off the note.
 * @param MIDIChannel Track channel to play note. Different from soundchip channel.
 * @param key is integer corresponding to which note to play
 * @param velocity is integer corresponding to which volume to play
 * @param verbose is boolean corresponding to whether or not to print error messages
 * @returns 0
 */
static int Mf_off(uint8 MIDIChannel, uint8 key, uint8 velocity, boolean verbose) {
	if (verbose) {
		cprintf(" %d,%d,%d\n", MIDIChannel, key, velocity);
	}
	audioMIDINoteOff(MIDIChannel, key, velocity);
	return(MFE_OK);
}


static int Mf_pressure(uint8 MIDIChannel, uint8 param0, uint8 param1) {
	// not supported by the VS1053
	return(MFE_OK);
}


static int Mf_controller(uint8 MIDIChannel, uint8 param0, uint8 param1) {
	// not supported by the VS1053
	return(MFE_OK);
}


static int Mf_pitchbend(uint8 MIDIChannel, uint8 param0, uint8 param1) {
	// not supported by the VS1053
	return(MFE_OK);
}


/*
 * @brief Change/set patch number.
 *
 * @param MIDIChannel is track channel to change/set patch number
 * @param program is patch number to change/set to
 * @returns 0
 */
static int Mf_program(uint8 MIDIChannel, uint8 program) {
	audioMIDIChangePatch(MIDIChannel, program);
	return(MFE_OK);
}


static int Mf_chanpressure(uint8 MIDIChannel, uint8 param0) {
	// not supported by the VS1053
	return(MFE_OK);
}


/*
 * @brief Print error message.
 *
 * @param code Type of error message
 * @returns code
 */
static int Mf_error(int8 code) {
    cprintf("MIDI error: %s", MIDI_err_msgs[-(code)]);
    return code;
}


/*
 * @brief Print error message.
 *
 * @param code Type of error message
 * @param arg Number at tail of message
 * @returns code
 */
static int Mf_error2(int8 code, int32 arg) {
    cprintf("MIDI error: %s %d\n", MIDI_err_msgs[-(code)], arg);
    return code;
}


static int Mf_seqnum(uint16 seqNum) {
	// not supported by the VS1053
	return(MFE_OK);
}


static int Mf_text(int msgType, int32 length, char * data) {
	// not supported by the VS1053
	return(MFE_OK);
}


static int Mf_marker (int msgType, int32 length, char * data) {
	// not supported by the VS1053
    return(MFE_OK);
}

static int Mf_cue (int msgType, int32 length, char * data) {
	// not supported by the VS1053
    return(MFE_OK);
}


/*
 * @brief set endOfTrack True.
 *
 * @param MIDITrackPtr trach ptr
 */
static int Mf_eot(MIDITrackStruct * MIDITrackPtr) {
    MIDITrackPtr->endOfTrack = TRUE;
	return(MFE_OK);
}

/*
 * @brief Set MIDI file tempo.
 *
 * @param tempo is tempo that we would like to set midi to
 * @returns 0
 */
static int Mf_tempo(uint32 tempo) {
	MIDITempoSet(tempo);
	return(MFE_OK);
}


static int Mf_timesig(int32 numer, int32 denom, int32 clocks, int32 qnotes){
	// not supported by the VS1053
	return(MFE_OK);
}

static int Mf_smpte(int32 hour, int32 min, int32 sec, int32 frame, int32 fract){
	// not supported by the VS1053
	return(MFE_OK);
}


static int Mf_keysig(int8 sharpFlat, int8 minor) {
	// not supported by the VS1053
	return(MFE_OK);
}


static int Mf_sqspecific(int32 junk, uint32 length, char * data) {
	// not supported by the VS1053
	return(MFE_OK);
}


/* NUM_PARAMS
 * @brief Returns the number of parameters for a given status byte, or -1 for
 * SysEx and meta-messages, which have a variable number of arguments.
 * @param stat status byte to query
 */
static int num_params(uint8 stat)
{
	if (stat >= MIDI_SYSEX)
		return(-1);	/* SysEx or meta */
	if (stat < MIDI_PROGRAM || stat >= MIDI_PITCHB)
		return(2);
	else
		return(1);
}


/* readUint32
 * @brief Reads a 32-bit unsigned number and returns it. MSB first.
 * Returns an error code upon error.
 */
static uint8 * readUint32(uint8 * dataPtr, uint32 * valPtr)
{
	int i;

	*valPtr = 0L;			/* Set 'retval to 0 initially */
	for (i = 0; i < 4; i++)	{	/* Read in 4 bytes into 'retval' */
		*valPtr <<= 8;
		*valPtr |= *dataPtr;
		dataPtr++;
	}

	return(dataPtr);			/* All went well */
}


/* readUint16
 * @brief Reads a 16-bit number, MSB first, and returns it.
 * Returns an error code upon error.
 */
static uint8 * readUint16(uint8 * dataPtr, uint16 * valPtr)
{
	*valPtr = (uint16)(*dataPtr++ << 8);
	*valPtr |= (uint16)*dataPtr++;
	return(dataPtr);			/* All went well */
}


/* READ_VARLEN
 * Reads a variable-length number, and returns it.
 * Returns an error code upon error.
 * This routine is copied almost verbatim from the MIDI 0.6 file specs.
 */
static uint8 * read_varlen(uint8 * dataPtr, uint32 * valPtr)
{
	uint8 i;

	*valPtr = 0;

	for (i = 0; i < 4; i++) {
		*valPtr = (*valPtr) << 7;
		*valPtr = *valPtr | (*dataPtr & 0x7f);
		if ((*dataPtr++ & 0x80) == 0) {
			break;
		}
	}

	return(dataPtr);
}


/* READ_SYSEX
 * @brief Read a system-exclusive/meta message, and pass it on to the user.
 * Warning: the buffer in which the SysEx data is stored will be reclaimed,
 * so the user is responsible for storing it if it is needed.
 * BTW, I'm doing some funky stuff with 'Mf_deltatime', so read the
 * comments at the beginning of 'read_event()'.
 */
//uint8 stat;			/* Type of SysEx message */
static int read_sysex(uint8 stat, MIDITrackStruct * MIDITrackPtr)
{
    char dataArray[MIDI_DATA_LENGTH];
	uint8 *data = (uint8 *)(dataArray);		/* Where the data is kept */
	uint32 length;		/* Length of message */
	long i;
    uint8 msg_type = 0;	/* Type of meta-event */

	if (stat == 0xff)	/* Meta message */
	{
		int retval = MFE_OK;

		msg_type = *(MIDITrackPtr->trackDataPtr++);

		/* Read length of meta-event */
		MIDITrackPtr->trackDataPtr = read_varlen(MIDITrackPtr->trackDataPtr, &length);

		if (length != 0L && length > MIDI_DATA_LENGTH) {
			return(Mf_error2(MFE_MEM, (int32)length));
        }

		/* Read in the meta-event */
		for (i = 0; i < length; i++) {
			data[i] = *(MIDITrackPtr->trackDataPtr++);
		}

		/* Take action according to the type of meta-event.
		 * In particular, make sure that the length of the
		 * meta-event is correct (where applicable).
		 */
		switch(msg_type) {
        case META_SEQNUM: {	/* Sequence number */
            short seqnum;

            if (length != 2) {	/* Check length */
                return(Mf_error2(MFE_ILLMLEN, (int32)length));
            }

            seqnum = ((short)(data[0] << 8)) | (short)(data[1]);
            retval = Mf_seqnum(seqnum);
            break;
        }

        case META_TEXT:		/* Text event */
        case META_COPYRIGHT:	/* Copyright notice */
        case META_SEQNAME:	/* Sequence name */
        case META_INSTNAME:	/* Instrument name */
        case META_LYRIC: {	/* Lyric */
            retval = Mf_text((int) msg_type,length, (char *)(data));
            break;
        }

        case META_MARKER: {	/* Marker */
            retval = Mf_marker((int) msg_type,length, (char *)(data));
            break;
        }

        case META_CUEPT: {	/* Cue point */
            retval = Mf_cue((int) msg_type,length, (char *)(data));
            break;
        }

        case META_EOT: {		/* End of track */
            if (length != 0L) {	/* Check length */
                return(Mf_error2(MFE_ILLMLEN, (int32)length));
            }
            retval = Mf_eot(MIDITrackPtr);
//            MIDITrackPtr->endOfTrack = TRUE;
            break;
        }

        case META_TEMPO: {	/* Set tempo */
            uint32 tempo;

            if (length != 3) {	/* Check length */
                return(Mf_error2(MFE_ILLMLEN, (int32)length));
            }
            tempo = stol(data,3);
            retval = Mf_tempo(tempo);
            break;
        }

        case META_SMPTE: {	/* SMPTE offset */
            int hour,min,sec,frame,fract;

            if (length != 5) {
                return(Mf_error(MFE_ILLMLEN), (int32) length);
            }
            hour  = (int) data[0];
            min   = (int) data[1];
            sec   = (int) data[2];
            frame = (int) data[3];
            fract = (int) data[4];
            retval = Mf_smpte(hour,min,	sec,frame,fract);
            break;
        }

        case META_TIMESIG: {	/* Time signature */
            int numer,denom,clocks,qnotes;

            if (length != 4) {
                return(Mf_error2(MFE_ILLMLEN, (int32) length));
            }
            numer  = (int) data[0];
            denom  = (int) data[1];
            clocks = (int) data[2];
            qnotes = (int) data[3];
            retval = Mf_timesig(numer, denom,clocks,qnotes);
            break;
        }

        case META_KEYSIG: {	/* Key signature */
            int8 sharpflat,minor;

            if (length != 2) {
                return(Mf_error2(MFE_ILLMLEN, (int32)length));
            }
            sharpflat = (int8) data[0];
            minor     = (int8) data[1];
            if (sharpflat > 7 || sharpflat < -7) {
                return(Mf_error2(MFE_ILLMVAL, (int32)data[0]));
            }
            if (minor != 0 && minor != 1) {
                return(Mf_error2(MFE_ILLMVAL, (int32)data[1]));
            }
            retval = Mf_keysig(sharpflat, minor);
            break;
        }
        case META_SEQSPEC: {	/* Sequencer-specific */
            retval = Mf_sqspecific(0, length, (char *)(data));
            break;
        }
        default: {
            /* TBD commented out */
            //retval = Mf_error(err_msgs[MFE_UKMETA]);
            break;
        }
		}
		return(retval);
	}

	if (stat == 0xf0) {	/* Syntactically complete message */
		cprintf("Sorry, no complete SysEx messages\n");
	}

	if (stat == 0xf7) {	/* Part of a complete SysEx message */
		cprintf("Sorry, no incomplete SysEx messages\n");
	}

	return(Mf_error2(MFE_ILLSETYPE, (int32)msg_type));
}


/* READ_EVENT
 *@brief Read an event, parse it by type, and pass the data to the user's
 * routines.
 * Returns MFE_OK if all goes well, or an error code otherwise.
 */
static int read_event(MIDITrackStruct * MIDITrackPtr, uint32 tracksToPlay) {
	int stat;			/* Current status */
	uint8 params[2];		/* Event parameters */
	int cur_param;			/* Parameter being currently read */
	int i;
	int returnVal;
	uint8 eventChannel, eventType;

	/* Read event type */
	stat = *(MIDITrackPtr->trackDataPtr++);
	if (stat & 0x80) {
		/* Is it a new event type? */
        MIDITrackPtr->runningStatus = stat;	/* Set new running status */
        cur_param = 0;			/* Start reading at 0th param */
    } else {
		params[0] = stat;	/* Record 1st parameter */
		cur_param = 1;			/* Start reading at 1st param */
	}

	/* Read the parameters corresponding to the status byte */
	for (i = num_params(MIDITrackPtr->runningStatus)-cur_param; i > 0; i--, cur_param++) {
		params[cur_param] = *(MIDITrackPtr->trackDataPtr++);	/* Record parameter */
	}

	// put the event type in the status struct
	eventType = (MIDITrackPtr->runningStatus & MIDI_CHANNEL_EVENT_TYPE_MASK);
	eventChannel = (MIDITrackPtr->runningStatus & MIDI_CHANNEL_EVENT_CHANNEL_MASK);
	currentEventType = eventType;

	/* Report event and parameters to user, depending on type of
	 * event.
	 */
	if ((eventType) == MIDI_SYSEX) {
		returnVal = read_sysex(MIDITrackPtr->runningStatus, MIDITrackPtr);
	}
	else if (tracksToPlay & (1 << MIDITrackPtr->index)) {
		switch(eventType) {
		case MIDI_NOTEOFF: {/* Note off */
				if (verbose) {
					cprintf("off %d ", MIDITrackPtr->index);
				}
				returnVal = Mf_off(eventChannel, params[0], params[1], verbose);
				break;
		}
		case MIDI_NOTEON: {	/* Note on */
			// set the flag for this track.
			if (verbose) {
				cprintf(" on %d ", MIDITrackPtr->index);
			}
			returnVal = Mf_on(eventChannel, params[0], params[1], verbose);
			break;
		}
		case MIDI_PRESSURE:	{/* Polyphonic key pressure */
			returnVal = Mf_pressure(eventChannel, params[0], params[1]);
			break;
		}
		case MIDI_CONTROL: {	/* Control change */
			returnVal = Mf_controller(eventChannel, params[0], params[1]);
			break;
		}
		case MIDI_PROGRAM: {	/* Program change */
			returnVal = Mf_program(eventChannel, params[0]);
			break;
		}
		case MIDI_CHANPRES:	{/* Channel pressure */
			returnVal = Mf_chanpressure(eventChannel, params[0]);
			break;
		}
		case MIDI_PITCHB: {	/* Pitch wheel change */
			returnVal = Mf_pitchbend(eventChannel, params[0], params[1]);
			break;
		}
		default: {
			return(Mf_error2(MFE_ILLSTAT, (int32)(eventType)));
		}
		}
	}
	/*
	else {
		return(Mf_error2(MFE_ILLSTAT, (int32)(MIDITrackPtr->runningStatus & 0xf0)));
	}
	*/

	return (returnVal);
}


/*
 * @brief Initialize the playing of the midi song.
 *
 * Reads in the header from the input file, file format, number of tracks, and quarter-note division.
 * Set up time division for file, find starting address for all tracks in this song, and initialize tempo.
 * @param MIDIDataPtr Pointer to midi file
 * @param tracksToPlay unused?
 * @returns the number of tracks in the file if all goes well, or an error
 * code otherwise (including if the user disapproves)
 */
static int MIDISongInit(uint8 * MIDIDataPtr, uint32 tracksToPlay) {
	int i;
	uint32 header_len;	/* Header length */
	uint16 format;		/* File format */
	uint32 trackLength;

	/* Reads in the header from the input file,
	 * Returns the number of tracks in the file if all goes well, or an error
	 * code otherwise (including if the user disapproves).
	 */

	/* See if the first four chars of the file contain "MThd" */
	if (strncmp((char *)MIDIDataPtr,"MThd",4) != 0) {
		return(Mf_error(MFE_HKWEXP));
	}
	MIDIDataPtr += 4;

	/* Read the number 6 (header length) from the header */
	MIDIDataPtr = readUint32(MIDIDataPtr, &header_len);
	if (header_len != 6L) {
		return(Mf_error2(MFE_ILLHLEN, (int32)header_len));		/* Incorrect header length */
	}

	/* Read the file format, number of tracks, and quarter-note division */
	MIDIDataPtr = readUint16(MIDIDataPtr, &format);
	if (format > 2) {
		return(Mf_error2(MFE_ILLFORM, (int32)format));
	}

	MIDIDataPtr = readUint16(MIDIDataPtr, &numberOfTracks);
	if (numberOfTracks > MIDI_TRACKS_MAX) {
		return(Mf_error2(MFE_TOO_MANY_TRACKS, (int32)(numberOfTracks)));
	}

	/* setup the time division for this file */
	MIDIDataPtr = readUint16(MIDIDataPtr, &division);

	/* Find the starting address for all the tracks in this song */
	for (i = 0; i < numberOfTracks; i++) {
		/* See if pointer contains "MTrk". In some future version,
		 * if the chunk type is unknown, then this section of code
		 * should just ignore it.
		 */
		if (strncmp((char *)MIDIDataPtr, "MTrk",4) != 0) {
			return(Mf_error(MFE_TKWEXP));
		}
		MIDIDataPtr += 4;

        /* clear MIDITracks[i] */
        MIDITracks[i] = MIDITrackInit;

		/* Read the length of the track */
		MIDIDataPtr = readUint32(MIDIDataPtr, &trackLength);
		if (trackLength > MIDI_MAX_TRACK_LENGTH) {
			return(Mf_error2(MFE_TRACK_TOO_LONG, (int32)trackLength));
		}
		MIDITracks[i].trackDataPtr = MIDIDataPtr;
		MIDITracks[i].trackDataStartPtr = MIDIDataPtr;
		MIDITracks[i].trackLength = trackLength;
		MIDITracks[i].endOfTrack = FALSE;
		MIDITracks[i].index = i;
		MIDITracks[i].runningStatus = 0;
		MIDIDataPtr += trackLength;
	}

    // initialize tempo to 80 (MIDI_DEFAULT_BPM) in case one isn't provided.
	MIDITempoSet(MIDI_DEFAULT_TEMPO);

    return MFE_OK;
}


/*
 * @brief Actual MIDI thread that parses through MIDI file and behaves accordingly.
 *
 * @returns void
 */
static void MIDIThread(void* parameters) {
    uint32 deltaTime;
    uint32 nextEventTime;
    uint32 minSleepTimeTX;
    uint32 songStartTimeTX;   /* starting time */
    uint8 finishedTracks;
    uint16 status;
    uint16 i;
    uint16 j;
	uint8 *songPtr = 0;
    boolean needToSleep;
	uint8 * nextAddr;
	uint32 currentTicks = osTaskGetTickCount();

	char string[10];

	for (;;) {
		if (playMidi) {
	        songStartTimeTX = osTaskGetTickCount();
			songPtr = (uint8 *)(midiMessage[MIDI_MSG_ADDRESS]);
	        MIDISongInit(songPtr, midiMessage[MIDI_MSG_TRACKS]);

	        if (verbose) {
				cprintf("MIDI Addr 0x%X TrackBits=%s\n", songPtr, bitString8(string, midiMessage[MIDI_MSG_TRACKS]));
	        }

	        finishedTracks = 0;

			currentMIDITicks = 0;
			currentMIDITime = 0;
			tempoChangeMIDITicks = 0;
			tempoChangeTime = songStartTimeTX;
	        needToSleep = FALSE;
			//songStartTimeTX = songStartTimeTX;

			while (finishedTracks < numberOfTracks) {
				finishedTracks = 0;
				minSleepTimeTX = 0;

				// convert tx ticks to MIDI ticks
				currentMIDITime = osTaskGetTickCount();

				currentMIDITicks = tempoChangeMIDITicks +
						((currentMIDITime - tempoChangeTime) * division) /
								(tempo / 1000);

				for (i = 0; i < numberOfTracks; i++) {
					needToSleep = FALSE;
					if (MIDITracks[i].endOfTrack) {
						finishedTracks++;
					}
					else {
						while ((needToSleep == FALSE) && (MIDITracks[i].endOfTrack == FALSE)) {
								//It is time to play the next event.

							// get next delta time;
							nextAddr = read_varlen(MIDITracks[i].trackDataPtr, &deltaTime);

							// find the time in us until the next event
							nextEventTime = MIDITracks[i].nextEventTime + deltaTime;

							if (nextEventTime <= currentMIDITicks) {
								if (verbose) {
									cprintf("now= %d, t= %d delta= %d\n", currentMIDITicks, MIDITracks[i].nextEventTime, deltaTime);
								}

								MIDITracks[i].nextEventTime = nextEventTime;

								//Why is he doing this?  We're just copying data?  Is this for lights?
								// update nextEventTimes[track] in status
								nextEventTimes[i] = MIDITracks[i].nextEventTime;

								//Update trackDataPtr
								MIDITracks[i].trackDataPtr = nextAddr;

								//Play event
								status = read_event(&MIDITracks[i], midiMessage[MIDI_MSG_TRACKS]);
							}
							else {
								needToSleep = TRUE;
								if (minSleepTimeTX == 0) {
									//This is incorrect. need to deal with different start times.
									minSleepTimeTX = nextEventTime;
								}
								else {
									if (nextEventTime <= minSleepTimeTX) {
										minSleepTimeTX = nextEventTime;
									}
								}
							}
						}
					}
					if (stopSong) {
	                    for (j = 0; j < numberOfTracks; j++) {
	                        MIDITracks[j].endOfTrack = TRUE;
	                    }
					}

				}
				//osTaskDelayUntil(&currentTicks, MIDI_THREAD_PERIOD);
				osTaskDelay(1);
			}
			stopSong = FALSE;
			playMidi = FALSE;
			audioNoteOffAll();
	        if (verbose) {
				cprintf("MIDI playback finished\n");
	        }
		}
		// give time for other tasks to run
		osTaskDelay(MIDI_THREAD_PERIOD_OUTER);
	}
}


void MIDIInit(void) {
	osTaskCreate(MIDIThread, "MIDI", 1024, NULL, MIDI_TASK_PRIORITY );
}


void MIDIFilePlay(const char* MIDIFilePtr) {
	//TODO: tracksMask is different for the function SCLPlayMIDIName. Check if we need this.
	uint16 tracksMask = 0xFFFF;

	if (MIDIFilePtr) {
		// get the data address.
		midiMessage[MIDI_MSG_ADDRESS] = (uint32)MIDIFilePtr;
		midiMessage[MIDI_MSG_TRACKS] = (uint32)tracksMask;
		playMidi = TRUE;
	}
}


boolean MIDIFileIsPlaying(void) {
	return playMidi;
}

#endif
